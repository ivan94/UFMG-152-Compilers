CÃ³digo fonte do lexer

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package br.ufmg.dcc.fernandes.ivan.masbcompiler.lexer;

import br.ufmg.dcc.fernandes.ivan.masbcompiler.lexer.Token.TokenType;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;

/**
 *
 * @author ivan
 */
public class Lexer {
    private BufferedReader reader;
    char[] buffer;
    int bufferPointer;
    public Lexer(Reader ir, int bufferSize){
        this.reader = new BufferedReader(ir);
        this.buffer = new char[bufferSize];
    }
    
    public Token readToken() throws IOException{
        this.bufferPointer = 0;
        
        ArrayList<TokenType> oldTokens = null;
        ArrayList<TokenType> newTokens = null;
        do{
            oldTokens = newTokens;
            reader.mark(buffer.length);
            int input = reader.read();
            buffer[bufferPointer] = (char)input;
            bufferPointer++;
            if(input == -1){
                break;
            }
            newTokens = getPossibleTokens();
        }while(newTokens != null && !newTokens.isEmpty());
        
        reader.reset();
        bufferPointer--;
        
        if(oldTokens == null){
            //Invalid character, no matches since begining
            return null;
        }
        
        TokenType token = null;
        for(TokenType t: oldTokens){
            if(token == null || t.getPriority() > token.getPriority()){
                token = t;
            }
        }
        return new Token(token, new String(buffer, 0, bufferPointer));
    }
    
    private ArrayList<TokenType> getPossibleTokens(){
        ArrayList<TokenType> possibilities = new ArrayList<>();
        String entry = new String(buffer, 0, bufferPointer);
        
        for(TokenType t : TokenType.values()){
            if(t.match(entry)){
                possibilities.add(t);
            }
        }
        
        return possibilities;
    }
}


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package br.ufmg.dcc.fernandes.ivan.masbcompiler.lexer;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 *
 * @author ivan
 */
public class Token {
    private TokenType type;
    private String value;

    public Token(TokenType type, String value) {
        this.type = type;
        this.value = value;
    }

    public TokenType getType() {
        return type;
    }

    public void setType(TokenType type) {
        this.type = type;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
    
   

    public static enum TokenType{
        ID(1, "[a-zA-Z][a-zA-Z0-9]*"),
        NUM(1, "[0-9]+"),
        REAL(1, "[0-9]+(.[0-9]+)?(e[\\+-]?[0-9]+)?"),
        DELIM(1, "[\\{\\}\\(\\)\\[\\]\\;\\s]"),
        ASSIGN(5, "="),
        BOOLOP(5, "(\\&\\&)|(\\|\\|)"),
        EQOP(5, "(==)|(!=)"),
        RELOP(5, "(<=)|(<)|(>=)|(>)"),
        SUMOP(5, "[\\+-]"),
        MULOP(5, "[\\*/]"),
        UNOP(5, "[!-]"),
        COMMENT(8, "//"),
        INT(10, "int"),
        CHAR(10, "char"),
        FLOAT(10, "float"),
        BOOL(10, "bool"),
        IF(10, "if"),
        ELSE(10, "else"),
        WHILE(10, "while"),
        DO(10, "do"),
        BREAK(10, "break"),
        TRUE(10, "true"),
        FALSE(10, "false");
        
        
        private int priority;
        private Pattern pattern;
        
        private TokenType(int priority, String regexString){
            this.priority = priority;
            this.pattern = Pattern.compile(regexString);
        }

        public int getPriority() {
            return priority;
        }
        
        public boolean match(String entry){
            Matcher m = this.pattern.matcher(entry);
            return (m.matches() && m.start() == 0 && m.end() == entry.length());
        }
    }
    
}
